using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Text;

namespace CPP
{
	public class Generator
	{
		private mainHeaderName = "api";

		private indent : string;

		public this(indent : string)
		{
			this.indent = indent;
		}

		public WriteCode(api : AST2.Api, rootDirectory : string) : void
		{
			def libDir    = Path.Combine(rootDirectory, "lib");
			def clientDir = Path.Combine(rootDirectory, "client");
			def serverDir = Path.Combine(rootDirectory, "server");

			foreach (dir in [rootDirectory, libDir, clientDir, serverDir])
				_ = Directory.CreateDirectory(dir);

			mutable headers     = List();
			mutable definitions = List();
			foreach (definition in api.Definitions.Values)
			{
				def ns = definition.ns;
				match (definition)
				{
				| Collection | Primitive | Void =>
					()
				| Const | Typedef =>
					definitions.Add(definition, ns);
				| Enum | Exception | Struct =>
					headers.Add(CreateDefinitionHeader(definition, ns, libDir));
				| Service as service =>
					CreateServerServiceIDs(service, ns, clientDir);
					CreateServerServiceIDs(service, ns, serverDir);

					CreateClientServiceHeader(service, ns, clientDir);
					CreateClientServiceImplementation(api, service, ns, clientDir);

					CreateServerServiceHeader(service, ns, serverDir);
					CreateServerServiceImplementation(api, service, ns, serverDir);
					CreateServerServiceStubs(service, ns, serverDir);
				}
			}
			headers.Sort();
			CreateMainHeader(headers, definitions, libDir);
		}

		//---------------
		// implementation
		//---------------

		private CreateDefinitionHeader
			( definition : AST2.Definition
			, ns         : AST2.Namespace
			, directory  : string
			) : string
		{
			def fileName = MakeApiFileName(ns, definition.name, ".h");
			using (writer = CreateFile(Path.Combine(directory, fileName)))
			{
				writer.WriteMember("#pragma once");
				WriteIncludes(writer);
				foreach (part in ns.Parts)
					writer.OpenBlock("namespace {0}", part);
				WriteDefinition(definition, writer);
				foreach (_ in ns.Parts)
					writer.CloseBlock();
			}
			fileName;
		}

		private CreateMainHeader
			( headers     : IEnumerable[string]
			, definitions : IEnumerable[AST2.Definition * AST2.Namespace]
			, directory   : string
			) : void
		{
			using (writer = CreateFile(MakeFilePath(directory, mainHeaderName, ".h")))
			{
				writer.WriteMember("#pragma once");
				foreach (definitions in GroupByNamespace(definitions))
				{
					def ns = definitions.Key;
					// open namespaces
					foreach (part in ns.Parts)
						writer.OpenBlock("namespace {0}", part);
					// write definitions
					foreach (definition in definitions)
						WriteDefinition(definition, writer);
					// close namespaces
					foreach (_ in ns.Parts)
						writer.CloseBlock();
				}
				foreach (header in headers)
					writer.WriteMember("#include \"{0}\"", header);
			}
		}

		private CreateClientServiceHeader
			( service   : AST2.Definition.Service
			, ns        : AST2.Namespace
			, directory : string
			) : void
		{
			using (writer = CreateFile(MakeFilePath(directory, service.name, ".h")))
			{
				writer.WriteMember("#pragma once");
				writer.WriteMember("#include \"FastTrackIpc/Api/{0}.h\"", mainHeaderName);
				WriteIncludes(writer);
				writer.WriteMember("class IProtocol;");

				foreach (part in ns.Parts)
					writer.OpenBlock("namespace {0}", part);

				match (service.@base)
				{
				| Some(@base) => writer.OpenBlock("class {0} : public {1}", service.name, @base);
				| None        => writer.OpenBlock("class {0}", service.name);
				}

				writer.WriteLabel("public");
				writer.WriteComment("interface");
				writer.WriteMember("{0}(IProtocol & protocol);", service.name);

				writer.WriteLabel("public");
				writer.WriteComment("service function wrappers");
				foreach (function in service.functions)
					WriteFunctionDefinition(function, false, writer);

				writer.WriteLabel("private");
				writer.WriteComment("data");
				writer.WriteMember("IProtocol & protocol;");

				writer.CloseBlock(addSemicolon = true);

				foreach (_ in ns.Parts)
					writer.CloseBlock();
			}
		}

		private CreateClientServiceImplementation
			( api       : AST2.Api
			, service   : AST2.Definition.Service
			, ns        : AST2.Namespace
			, directory : string
			) : void
		{
			def MakeClassName()
			{
				def name = StringBuilder();
				foreach (part in ns.Parts)
				{
					_ = name.Append(part);
					_ = name.Append("::");
				}
				_ = name.Append(service.name);
				_ = name.Append("::");
				name.ToString();
			}
			def className = MakeClassName();

			def WriteConstructor(writer)
			{
				writer.OpenBlock
					( "{0}::{1}(IProtocol & protocol) : protocol(protocol)"
					, className
					, service.name
					);
				writer.CloseBlock();
			}

			def WriteWrapper(function, writer)
			{
				WriteFunctionDeclaration(className, function, false, writer);
				writer.WriteMember("protocol.writeInt32({0}ID_{1});", service.name, function.Name);
				foreach (field in function.Fields)
					WriteWriteStatement(api, field.Name, field.Type, writer);
				WriteReadStatement(api, "result", function.ReturnType, true, writer);
				writer.WriteMember("return result;");
				writer.CloseBlock();
			}

			using (writer = CreateFile(MakeFilePath(directory, service.name, ".cpp")))
			{
				writer.WriteMember("#include \"{0}.h\"", service.name);
				writer.WriteMember("#include \"{0}ID.h\"", service.name);
				writer.WriteMember("#include \"FastTrackIpc/IProtocol.h\"");

				WriteConstructor(writer);

				writer.WriteComment("service function wrappers");
				foreach (function in service.functions)
					WriteWrapper(function, writer);
			}
		}

		private CreateServerServiceHeader
			( service   : AST2.Definition.Service
			, ns        : AST2.Namespace
			, directory : string
			) : void
		{
			using (writer = CreateFile(MakeFilePath(directory, service.name, ".h")))
			{
				writer.WriteMember("#pragma once");
				WriteIncludes(writer);
				writer.WriteMember("#include \"FastTrackIpc/Api/{0}.h\"", mainHeaderName);
				writer.WriteMember("#include \"FastTrackIpc/IProcessor.h\"");
				writer.WriteMember("class IProtocol;");

				foreach (part in ns.Parts)
					writer.OpenBlock("namespace {0}", part);

				match (service.@base)
				{
				| Some(@base) => writer.OpenBlock("class {0} : public IProcessor, public {1}", service.name, @base);
				| None        => writer.OpenBlock("class {0} : public IProcessor", service.name);
				}

				writer.WriteLabel("public");
				writer.WriteComment("IProcess implementation");
				writer.WriteMember("virtual bool process(IProtocol & protocol) const;");

				writer.WriteLabel("private");
				writer.WriteComment("service functions for the user to implement");
				foreach (function in service.functions)
					WriteFunctionDefinition(function, true, writer);

				writer.WriteLabel("private");
				writer.WriteComment("generated wrappers");
				foreach (function in service.functions)
				{
					writer.WriteMember
						( "void process_{0}(IProtocol & protocol) const;"
						, function.Name
						);
				}

				writer.CloseBlock(addSemicolon = true);

				foreach (_ in ns.Parts)
					writer.CloseBlock();
			}
		}

		private CreateServerServiceIDs
			( service   : AST2.Definition.Service
			, ns        : AST2.Namespace
			, directory : string
			) : void
		{
			using (writer = CreateFile(MakeFilePath(directory, service.name + "ID", ".h")))
			{
				writer.WriteMember("#pragma once");

				foreach (part in ns.Parts)
					writer.OpenBlock("namespace {0}", part);

				writer.OpenBlock("enum {0}ID", service.name);
				foreach (function in service.functions)
					writer.WriteMember("{0}ID_{1},", service.name, function.Name);
				writer.CloseBlock();

				foreach (_ in ns.Parts)
					writer.CloseBlock(addSemicolon = true);
			}
		}

		private CreateServerServiceImplementation
			( api       : AST2.Api
			, service   : AST2.Definition.Service
			, ns        : AST2.Namespace
			, directory : string
			) : void
		{
			def MakeClassName()
			{
				def name = StringBuilder();
				foreach (part in ns.Parts)
				{
					_ = name.Append(part);
					_ = name.Append("::");
				}
				_ = name.Append(service.name);
				_ = name.Append("::");
				name.ToString();
			}
			def className = MakeClassName();

			def WriteSwitch(writer)
			{
				writer.OpenBlock("bool {0}::process(IProtocol & protocol) const", className);
				writer.WriteMember("int id = protocol.readInt32();");
				writer.OpenBlock("switch (id)");
				foreach (function in service.functions)
				{
					writer.WriteLabel("case {0}ID_{1}", service.name, function.Name);
					writer.WriteMember("process_{0}(protocol);", function.Name);
					writer.WriteMember("break;");
				}
				writer.WriteLabel("default");
				writer.WriteMember("throw std::runtime_error(\"{0}::process: unknown ID\");", className);
				writer.CloseBlock();
				writer.WriteMember("return true;");
				writer.CloseBlock();
			}

			def WriteWrapper(function, writer)
			{
				writer.OpenBlock
					( "void {0}::process_{1}(IProtocol & protocol) const"
					, className
					, function.Name
					);
				foreach (field in function.Fields)
					WriteReadStatement(api, field.Name, field.Type, true, writer);
				unless (function.ReturnType.Definition is AST2.Definition.Void)
				{
					writer.WriteMember
						( "{0} result = this->{1}({2});"
						, ToString(function.ReturnType)
						, function.Name
						, string.Join(", ", function.Fields.Select(_.Name))
						);
					WriteWriteStatement(api, "result", function.ReturnType, writer);
				}
				writer.CloseBlock();
			}

			using (writer = CreateFile(MakeFilePath(directory, service.name, ".cpp")))
			{
				writer.WriteMember("#include \"{0}.h\"", service.name);
				writer.WriteMember("#include \"{0}ID.h\"", service.name);
				writer.WriteMember("#include \"FastTrackIpc/IProtocol.h\"");

				writer.WriteComment("IProcess implementation");
				WriteSwitch(writer);

				writer.WriteComment("service function wrappers");
				foreach (function in service.functions)
					WriteWrapper(function, writer);
			}
		}

		private CreateServerServiceStubs
			( service   : AST2.Definition.Service
			, ns        : AST2.Namespace
			, directory : string
			) : void
		{
			def MakeClassName()
			{
				def name = StringBuilder();
				foreach (part in ns.Parts)
				{
					_ = name.Append(part);
					_ = name.Append("::");
				}
				_ = name.Append(service.name);
				_ = name.Append("::");
				name.ToString();
			}
			def className = MakeClassName();

			def WriteStub(function, writer)
			{
				WriteFunctionDeclaration(className, function, true, writer);
				writer.WriteComment("add function implementation here");
				writer.CloseBlock();
			}
			using (writer = CreateFile(MakeFilePath(directory, service.name + "_impl", ".cpp")))
			{
				writer.WriteMember("#include \"{0}.h\"", service.name);

				writer.WriteComment("service functions for the user to implement");
				foreach (function in service.functions)
					WriteStub(function, writer);
			}
		}

		private GroupByNamespace
			( definitions : IEnumerable[AST2.Definition * AST2.Namespace]
			) : IEnumerable[IGrouping[AST2.Namespace, AST2.Definition]]
		{
			definitions.GroupBy
				( keySelector     = (_, ns) => ns
				, elementSelector = (defn, _) => defn
				)
		}

		private MakeApiFileName
			( ns        : AST2.Namespace
			, name      : string
			, extension : string
			) : string
		{
			def fileName = StringBuilder();
			foreach (part in ns.Parts)
			{
				_ = fileName.Append(part);
				_ = fileName.Append("_");
			}
			_ = fileName.Append(name);
			_ = fileName.Append(extension);
			fileName.ToString();
		}

		private MakeFilePath
			( directory : string
			, fileName  : string
			, extension : string
			) : string
		{
			Path.Combine(directory, fileName + extension)
		}


		private PassByValue(ty : AST2.Type) : bool
		{
			match (ty.Definition)
			{
			| Enum        => true
			| Primitive   => true
			| Typedef(ty) => PassByValue(ty)
			| _                           => false
			}
		}

		private WriteDefinition
			( definition  : AST2.Definition
			, writer      : CodeWriter
			) : void
		{
			def name = definition.name;

			match (definition)
			{
			| Collection =>
				throw GeneratorException("ICE: called WriteDefinition for a collection type.");

			| Const(ty, value) =>
				writer.WriteMember("const {0} {1} = {2};", ToString(ty), name, ToString(value))

			| Enum(members) =>
				writer.OpenBlock("enum {0}", name);
				foreach (member in members)
				{
					match (member.Value)
					{
					| Some(num) => writer.WriteMember("{0} = {1},", member.Name, num)
					| None      => writer.WriteMember("{0},", member.Name)
					}
				}
				writer.CloseBlock(addSemicolon = true);

			| Exception(fields) =>
				writer.OpenBlock("class {0} : public std::exception", name);
				foreach (field in fields)
					writer.WriteMember("{0} {1};", ToString(field.Type), field.Name);
				writer.CloseBlock(addSemicolon = true);

			| Primitive =>
				throw GeneratorException("ICE: called WriteDefinition for a primitive type.");

			| Service => ()

			| Struct(fields) =>
				writer.OpenBlock("class {0}", name);
				foreach (field in fields)
					writer.WriteMember("{0} {1};", ToString(field.Type), field.Name);
				writer.CloseBlock(addSemicolon = true);

			| Typedef(ty) =>
				writer.WriteMember("typedef {0} {1};", ToString(ty), name);

			| Void =>
				throw GeneratorException("ICE: called WriteDefinition for the void type.");
			}
		}

		// Must be followed by writer.CloseBlock()
		private WriteFunctionDeclaration
			( className : string
			, function  : AST2.Function
			, isConst   : bool
			, writer    : CodeWriter
			) : void
		{
			def FieldToString(f)
			{
				if (PassByValue(f.Type))
					string.Format("{0} {1}", ToString(f.Type), f.Name)
				else
					string.Format("const {0} & {1}", ToString(f.Type), f.Name)
			}
			writer.OpenBlock
				( "{0} {1}::{2}({3}){4}"
				, ToString(function.ReturnType)
				, className
				, function.Name
				, string.Join(", ", function.Fields.Select(FieldToString))
				, if (isConst) " const" else ""
				);
		}

		private WriteFunctionDefinition
			( function : AST2.Function
			, isConst  : bool
			, writer   : CodeWriter
			) : void
		{
			def FieldToString(f)
			{
				string.Format("{0} {1}", ToString(f.Type), f.Name)
			}

			writer.WriteMember
				( "{0} {1}({2}){3};"
				, ToString(function.ReturnType)
				, function.Name
				, string.Join(", ", function.Fields.Select(FieldToString))
				, if (isConst) " const" else ""
				);
		}

		private WriteIncludes(writer : CodeWriter) : void
		{
			def includes = [ "map", "set", "stdexcept", "stdint.h", "vector" ];
			foreach (entry in includes)
				writer.WriteMember("#include <{0}>", entry);
		}

		private WriteReadStatement
			( api        : AST2.Api
			, name       : string
			, ty         : AST2.Type
			, declareLhs : bool
			, writer     : CodeWriter
			) : void
		{
			def Decl(tyName)
			{
				if (declareLhs) tyName + " " else ""
			}
			match (ty.Definition.name)
			{
			| "binary" =>
				// make binary a list<byte>
				def listType = AST2.Type(api.Definitions["list"], [ AST2.Type(api.Definitions["byte"], []) ]);
				WriteReadStatement(api, name, listType, false, writer);
			| "bool" =>
				writer.WriteMember("{0}{1} = protocol.readBool();", Decl("bool"), name);
			| "byte" =>
				writer.WriteMember("{0}{1} = protocol.readInt8();", Decl("int8_t"), name);
			| "double" =>
				writer.WriteMember("{0}{1} = protocol.readDouble();", Decl("double"), name);
			| "i16" =>
				writer.WriteMember("{0}{1} = protocol.readInt16();", Decl("int16_t"), name);
			| "i32" =>
				writer.WriteMember("{0}{1} = protocol.readInt32();", Decl("int32_t"), name);
			| "i64" =>
				writer.WriteMember("{0}{1} = protocol.readInt64();", Decl("int64_t"), name);
			| "list" =>
				// assume no nested collections
				writer.WriteMember("{0} {1}(protocol.readInt32());", ToString(ty), name);
				writer.OpenBlock("for (int i = 0, size = {0}.size(); i != size; ++i)", name);
				WriteReadStatement(api, $"$name[i]", ty.Parameters.Head, false, writer);
				writer.CloseBlock();
			| "map"    => () // TODO
			| "set"    => () // TODO
			| "string" =>
				writer.WriteMember("std::string {0} = protocol.readString();", name);
			| "void"   => ()
			| tyName =>
				match (ty.Definition)
				{
				| Enum =>
					writer.WriteMember("{0}{1} = static_cast<{2}>(protocol.readInt32());", Decl(tyName), name, tyName);
				| Struct | Exception =>
					when (declareLhs)
						writer.WriteMember("{0} {1};", ToString(ty), name);
					writer.WriteMember("{0}.read(protocol);", name);
				| Typedef(ty) =>
					WriteReadStatement(api, name, ty, declareLhs, writer)
				| _ => ()
				}
			}
		}

		private WriteWriteStatement
			( api    : AST2.Api
			, name   : string
			, ty     : AST2.Type
			, writer : CodeWriter
			) : void
		{
			match (ty.Definition.name)
			{
			| "binary" =>
				// make binary a list<byte>
				def listType = AST2.Type(api.Definitions["list"], [ AST2.Type(api.Definitions["byte"], []) ]);
				WriteWriteStatement(api, name, listType, writer);
			| "bool" =>
				writer.WriteMember("protocol.writeBool({0});", name);
			| "byte" =>
				writer.WriteMember("protocol.writeInt8({0});", name);
			| "double" =>
				writer.WriteMember("protocol.writeDouble({0});", name);
			| "i16" =>
				writer.WriteMember("protocol.writeInt16({0});", name);
			| "i32" =>
				writer.WriteMember("protocol.writeInt32({0});", name);
			| "i64" =>
				writer.WriteMember("protocol.writeInt64({0});", name);
			| "list" =>
				writer.WriteMember("protocol.writeInt32({0}.size());", name);
				writer.OpenBlock("for (int i = 0, size = {0}.size(); i != size; ++i)", name);
				WriteWriteStatement(api, $"$name[i]", ty.Parameters.Head, writer);
				writer.CloseBlock();
			| "map"    => ()
			| "set"    => ()
			| "string" =>
				writer.WriteMember("protocol.writeString({0});", name);
			| "void"   => ()
			| _ =>
				match (ty.Definition)
				{
				| Enum =>
					writer.WriteMember("protocol.writeInt32({0});", name);
				| Struct | Exception =>
					writer.WriteMember("{0}.write(protocol);", name);
				| Typedef(ty) =>
					WriteWriteStatement(api, name, ty, writer)
				| _ => ()
				}
			}
		}

		private ToString(ty : AST2.Type) : string
		{
			def (name, parameters) = match (ty.Definition.name)
			{
			| "binary" => ("std::vector", [ "int8_t" ])
			| "bool"   => ("bool",    [])
			| "byte"   => ("int8_t",  [])
			| "double" => ("double",  [])
			| "i16"    => ("int16_t", [])
			| "i32"    => ("int32_t", [])
			| "i64"    => ("int64_t", [])
			| "list"   => ("std::vector", ty.Parameters.Map(ToString))
			| "map"    => ("std::map",    ty.Parameters.Map(ToString))
			| "set"    => ("std::set",    ty.Parameters.Map(ToString))
			| "string" => ("std::string", [])
			| "void"   => ("void", [])
			| name     => (name,   [])
			}
			match (string.Join(", ", parameters))
			{
			| ""                     => name
			| p when p.EndsWith(">") => string.Format("{0}<{1} >", name, p)
			| p                      => string.Format("{0}<{1}>",  name, p)
			}
		}

		private ToString(ty : AST2.Constant) : string
		{
		| Int(x) => x.ToString();
		}

		private CreateFile(path : string) : CodeWriter
		{
			def writer = CodeWriter(indent, File.CreateText(path));
			writer.WriteComment("Automatically generated file");
			writer;
		}
	}
}
